<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">ðŸš¢ Debugging for Dockerized ML applications in Python</h1><p class="page-description">Using VScode and debugpy to make debugging a breeze</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2021-07-31T00:00:00-05:00" itemprop="datePublished">
        Jul 31, 2021
      </time>â€¢ 
          <span itemprop="author" itemscope itemtype="http://schema.org/Person">
            <span class="p-author h-card" itemprop="name">Sam Watts</span></span>
       â€¢ <span class="read-time" title="Estimated read time">
    
    
      4 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/blog/categories/#ml">ml</a>
        &nbsp;
      
        <a class="category-tags-link" href="/blog/categories/#python">python</a>
        
      
      </p>
    

    </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#why-do-we-need-this">Why do we need this?</a></li>
<li class="toc-entry toc-h2"><a href="#the-solution">The Solution</a>
<ul>
<li class="toc-entry toc-h3"><a href="#1-configuring-debugpy-in-python">1. Configuring debugpy in Python</a></li>
<li class="toc-entry toc-h3"><a href="#2-configuring-the-connection-to-the-docker-container">2. Configuring the connection to the Docker container</a></li>
<li class="toc-entry toc-h3"><a href="#3-setting-up-breakpoints">3. Setting up breakpoints</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#debugging-in-action">Debugging in action</a></li>
<li class="toc-entry toc-h2"><a href="#links">Links</a></li>
</ul><p>Docker has become ubiquitous in ML applications in the last few years. It can enable easy collaboration between engineers with different hardware â€” as well as easing the transition from prototyping on personal laptops to compute clusters in production. On the flip side, it introduces an extra layer of complexity for engineers to work with when developing and maintaining productionised models.</p>

<p>In my professional work, Iâ€™ve found debugging to be one of the things made harder by this extra layer of complexity. In this post Iâ€™m going to outline my current setup with VSCode and debugpy that greatly simplifies this process when applied to a model training application.</p>

<h2 id="why-do-we-need-this">
<a class="anchor" href="#why-do-we-need-this" aria-hidden="true"><span class="octicon octicon-link"></span></a>Why do we need this?</h2>

<p>When debugging code, we want to be able to inspect its environment at runtime as accurately as possible. Any deviation from this can lead to fixes that plainly donâ€™t work in the runtime environment.</p>

<p>Whilst getting to grips with Docker, my debugging process would generally entail recreating the scaffolding around the Python script that I wanted to inspect in my local development environment, and then debugging that script directly. In model training applications that contain bash scripts, multiple entrypoints and use of environment variables, this can quickly add a large development overhead. With this added complexity comes the increased chance of errors creeping in, rendering the whole process slow and frustrating.</p>

<p>So how do we avoid this? We need a debugging system that can interact with Docker, and let our code run as it was designed to!</p>

<h2 id="the-solution">
<a class="anchor" href="#the-solution" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Solution</h2>

<p>What worked best in the end for me is a debugger that can connect to a Docker container where your model training application is running, and directly inspect the environment of a given Python script.</p>

<p>This is where debugpy comes in!</p>

<p>Previously known as ptvsd, this package is developed by Microsoft specifically for use in VSCode with Python. It implements all of the common debugging tools you would expect, as well as allowing for attaching to remote environments, such as Docker containers or even remote machines via SSH.</p>

<p>As an aside, debugpy implements the Debug Adapter Protocol (DAP), which is a standardised way for development tools to communicate with debuggers.</p>

<p>Using debugpy with Docker containers is wonderfully simple, and requires 3 distinct steps. Iâ€™ll dive into each of these in turn, before demonstrating the whole process afterwards.</p>

<ol>
  <li>Configuring debugpy in Python</li>
  <li>Configuring the connection to the Docker container</li>
  <li>Setting up breakpoints</li>
</ol>

<h3 id="1-configuring-debugpy-in-python">
<a class="anchor" href="#1-configuring-debugpy-in-python" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. Configuring debugpy in Python</h3>

<p>In the script you would like to debug, the following snippet should be added before any other code.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">debugpy</span>

<span class="n">debugpy</span><span class="p">.</span><span class="n">listen</span><span class="p">((</span><span class="s">"0.0.0.0"</span><span class="p">,</span> <span class="mi">5678</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Waiting for client to attach..."</span><span class="p">)</span>
<span class="n">debugpy</span><span class="p">.</span><span class="n">wait_for_client</span><span class="p">()</span>
</code></pre></div></div>

<p>This will setup debugpy to listen on port 5678 for a client to attach, and will also pause the execution until a client connects via that port.</p>

<h3 id="2-configuring-the-connection-to-the-docker-container">
<a class="anchor" href="#2-configuring-the-connection-to-the-docker-container" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. Configuring the connection to the Docker container</h3>

<p>Now we have our Python script configured, we need to make sure the VSCode debugger client can connect to debugpy when it is running inside a Docker container.</p>

<p>Firstly, when you run your Docker container, the port that debugpy is listening on must be mapped to a local port</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="se">\</span>
    <span class="nt">-p</span> 5678:5678 <span class="se">\ </span> <span class="c"># map container port to local port</span>
    temp-container
</code></pre></div></div>

<p>Secondly, we need to create a launch.json file to configure how the local VSCode debugging client will run. This minimal example tells the debugger to attach to port 5678, which will be mapped to the Docker port of the same number when we run the container.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
   </span><span class="nl">"version"</span><span class="p">:</span><span class="s2">"0.2.0"</span><span class="p">,</span><span class="w">
   </span><span class="nl">"configurations"</span><span class="p">:[</span><span class="w">
      </span><span class="p">{</span><span class="w">
         </span><span class="nl">"name"</span><span class="p">:</span><span class="s2">"Python: Docker Attach"</span><span class="p">,</span><span class="w">
         </span><span class="nl">"type"</span><span class="p">:</span><span class="s2">"python"</span><span class="p">,</span><span class="w">
         </span><span class="nl">"request"</span><span class="p">:</span><span class="s2">"attach"</span><span class="p">,</span><span class="w">
         </span><span class="nl">"connect"</span><span class="p">:{</span><span class="w">
            </span><span class="nl">"host"</span><span class="p">:</span><span class="s2">"localhost"</span><span class="p">,</span><span class="w">
            </span><span class="nl">"port"</span><span class="p">:</span><span class="mi">5678</span><span class="w">
         </span><span class="p">},</span><span class="w">
         </span><span class="nl">"pathMappings"</span><span class="p">:[</span><span class="w">
            </span><span class="p">{</span><span class="w">
               </span><span class="nl">"localRoot"</span><span class="p">:</span><span class="s2">"${workspaceFolder}"</span><span class="p">,</span><span class="w">
               </span><span class="nl">"remoteRoot"</span><span class="p">:</span><span class="s2">"."</span><span class="w">
            </span><span class="p">}</span><span class="w">
         </span><span class="p">]</span><span class="w">
      </span><span class="p">}</span><span class="w">
   </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h3 id="3-setting-up-breakpoints">
<a class="anchor" href="#3-setting-up-breakpoints" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. Setting up breakpoints</h3>

<p>I was surprised when I first tried this that when you set breakpoints via the VSCode UI on the local version of a Python script, that will correspond to the copied scripts that run inside your Docker container! Pure wizardry from VSCode.</p>

<p>In addition, you can also use <code class="language-plaintext highlighter-rouge">debugpy.breakpoint()</code> to explicitly set breakpoints via the debugpy API. An additional benefit of this is that these calls will be ignored if you exclude the debugpy configuration mentioned in step <code class="language-plaintext highlighter-rouge">(1)</code>, providing a quick way of temporarily removing debugging.</p>

<h2 id="debugging-in-action">
<a class="anchor" href="#debugging-in-action" aria-hidden="true"><span class="octicon octicon-link"></span></a>Debugging in action</h2>

<p>You should be good to go! The steps to debug are:</p>

<ol>
  <li>Add breakpoints in the UI</li>
  <li>Rebuild and run the Docker container</li>
  <li>Connect the debugger</li>
</ol>

<p><img src="/blog/images/2021-07-31-debugging-dockerized-ml-python/1_tkD-QqtcEtUs6IdRTiDh2A.gif" alt="" title="The full debugging process"></p>

<p>The full code used for this example can be found below. Happy debugging! ðŸ˜ƒ</p>

<p><a href="https://github.com/sam-watts/vscode-docker-debugging">GitHub - sam-watts/vscode-docker-debugging: A template for debugging long running, dockerized programs in python with vscode</a></p>

<h2 id="links">
<a class="anchor" href="#links" aria-hidden="true"><span class="octicon octicon-link"></span></a>Links</h2>

<ul>
  <li>debugpy Github: <a href="https://github.com/microsoft/debugpy">https://github.com/microsoft/debugpy</a>
</li>
  <li>Docker run reference: <a href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a>
</li>
</ul>

  </div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="sam-watts/blog"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/blog/ml/python/2021/07/31/debugging-dockerized-ml-python.html" hidden></a>
</article>
